<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>TSEnsemble.arima API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>TSEnsemble.arima</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
from statsmodels.tsa.arima.model import ARIMA
import time
from TSEnsemble import utils
import pandas as pd
import matplotlib.pyplot as plt

def root_test(model, aic):
    &#34;&#34;&#34;
    Check the roots of the new model, and set AIC to inf if the roots are
    near non-invertible. 
    Args:
        model (object): Model object.
        aic (float): AIC value of model.

    Returns:
        float: Updated AIC value.
    &#34;&#34;&#34;
    max_invroot = 0
    p, d, q = model.order
    P, D, Q, m = model.S

    if p + P &gt; 0:
        max_invroot = max(0, *np.abs(1 / model.arroots))
    if q + Q &gt; 0 and np.isfinite(aic):
        max_invroot = max(0, *np.abs(1 / model.maroots))

    if max_invroot &gt; 0.99:
        aic = np.inf
    return aic

def auto_arima(dataset, 
               method = &#39;stepwise&#39;, 
               max_p = 3, 
               d = None, 
               D = None, 
               max_q = 3, 
               season = None, 
               max_P = 3, 
               max_Q = 3, 
               verbose = True, 
               train_size = None,
               train_split = None, 
               plot = True, 
               fig_size = (15,5),
               max_plot = 200):
    &#34;&#34;&#34;
    Automatically find the best parameters for (S)AR(I)MA model 
    
    Args:
        dataset (DataFrame, ndarray): dataset to use.
        method (&#39;stepwise&#39;, &#39;grid&#39;): Method for finding the optimal parameters.
        d, D (int): specify d, D parameters.
        max_q, max_p, max_P, max_Q (int): maximum values of parameters.
        season (int): required for Seasonal ARIMA. Seasonality of time series.
        verbose (bool): print additional information.
        train_size (float): Value from 0 to 1 to specify fraction of train dataset. Default value : 0.9. alias : train_split
        plot (bool): plot predicted and observed values for test dataset.
        fig_size (tuple(int, int)):  size of a plot.
        max_plot(int): maximum number of values to plot.

    Returns:
        object: Optimal ARIMA model.
    &#34;&#34;&#34;

    if train_size is None and train_split is None:
        train_split = 0.9
    elif train_split is None and not(train_size is None):
        train_split = train_size

    if hasattr(dataset, &#39;values&#39;):
        dataset = dataset.values
    
    if (np.isnan(dataset).any()):
        dataset = utils.interpolate_nan(dataset)

    # try to find correct d value
    is_stationary = utils.isStationaryArray(dataset, plot = False, verbose = False)
    if not(is_stationary) and d is None:
        for i in range(3):
                # check if differentiating i times makes data stationary
                if utils.isStationaryArray(np.diff(dataset.squeeze(), n = i + 1), plot = False, verbose = False):
                    d = i + 1
                    break
        if d is None:
            print(&#34;Cannot transform data to Stationary. Using ARIMA model would be inappropriate&#34;)
            d = 3
    elif d is None:
        d = 0
    if D is None:
       D = d     


    train_size = int(len(dataset) * train_split)
    train_data = dataset[:train_size]
    test_data = dataset[train_size:]
    train_data = list(np.concatenate(train_data).flat) 
    test_data = list(np.concatenate(test_data).flat) 


    if method == &#39;stepwise&#39;:
        model = stepwise_auto_arima(train_data, max_p = max_p, d = d, max_q = max_q, season = season, max_P = max_P, D = D, max_Q = max_Q)
    elif method == &#39;grid&#39;:
        model = grid_auto_arima(train_data, max_p = max_p, d = d, max_q = max_q, season = season, max_P = max_P, D = D, max_Q = max_Q)
    else:
        return &#34;method should be grid or stepwise&#34;

    predictions = model.forecast(len(test_data))

    if plot:
            plt.figure(figsize=fig_size)
            plt.plot(test_data[-max_plot:], label = &#34;Actual&#34;)
            plt.plot(predictions[-max_plot:], label = &#34;Prediction&#34;)               
            plt.ylabel(&#39;Values&#39;, fontsize=15)
            plt.legend()
            plt.show()

    if verbose == False:
        return model
    
    print(pd.DataFrame({&#39;prediction&#39; : predictions, &#39;actual&#39; : test_data}))

    rmse = utils.get_rmse(predictions, test_data)
    mse = utils.get_mse(predictions, test_data)
    mae = utils.get_mae(predictions, test_data)
    mape = utils.get_mape(predictions, test_data)

    print(&#34;RMSE = {}, MSE = {}, MAE = {}, MAPE = {}&#34;.format(rmse, mse, mae, mape))

    return model
# evaluate combinations of p, d and q values for an ARIMA model
def grid_auto_arima(data, max_p = 3, d = None, max_q = 3, season = None, max_P = 3, D = None, max_Q = 3):
    &#34;&#34;&#34;
    Evaluate combinations of p, d and q values for an ARIMA model using grid search
    Args:
        data (DataFrame, ndarray): dataset to use.
        d, D (int): specify d, D parameters.
        max_q, max_p, max_P, max_Q (int): maximum values of parameters.
        season (int): required for Seasonal ARIMA. Seasonality of time series.
    Returns:
        object: Optimal ARIMA model.
    &#34;&#34;&#34;
    
    best_aic, best_model, = float(&#34;inf&#34;), None
    if season is None:
        for p in range(0, max_p + 1):
            for q in range(0, max_q + 1):
                try:
                    if p == 0 and q == 0:
                        continue
                    model = model_arima(data, [p, d, q])
                    if model.aic &lt; best_aic:
                        best_aic, best_model = model.aic, model
                except:
                    continue
        if d == 0:
            print(&#39;Best ARMA%s  AIC=%.3f&#39; % (best_model, best_aic))
        else:
            print(&#39;Best ARIMA%s  AIC=%.3f&#39; % (best_model, best_aic))
    else:
        for p in range(0, max_p + 1):
            for q in range(0, max_q + 1):
                for P in range(0, max_P + 1):
                    for Q in range(0, max_Q + 1):
                        try:
                            if p == 0 and q == 0:
                                continue
                            model = model_arima(data, (p, d, q), S = (P, D, Q, season))
                            if model.aic &lt; best_aic:
                                best_aic, best_model = model.aic, model
                        except:
                                continue
        if d == 0 and D == 0:
            print(&#39;Best SARMA%s  AIC=%.3f&#39; % (best_model.order, best_aic))
        else:
            print(&#39;Best SARIMA%s  AIC=%.3f&#39; % (best_model.order, best_aic))
    return best_model

def stepwise_auto_arima(data, max_p = 3, d = None, max_q = 3, season = None, max_P = 3, D = None, max_Q = 3):
    &#34;&#34;&#34;
    Stepwise approach to find the best parameters for (S)AR(I)MA model
    Args:
        data (DataFrame, ndarray): dataset to use.
        d, D (int): specify d, D parameters.
        max_q, max_p, max_P, max_Q (int): maximum values of parameters.
        season (int): required for Seasonal ARIMA. Seasonality of time series.
    Returns:
        object: Optimal ARIMA model.
    &#34;&#34;&#34;

    best_model = [np.inf,[],[],None]

    def minAic(order):
        &#34;&#34;&#34;
        Compare given parameters of model to the current best
        &#34;&#34;&#34;
        nonlocal best_model
        model = model_arima(data, order)
        if model.aic &lt; best_model[0]:
            best_model[0], best_model[1], best_model[3] = model.aic, order, model
        return 
    
    def minAicS(order, S):
        &#34;&#34;&#34;
        Compare given parameters of model to the current best for Seasonal AR(I)MA
        &#34;&#34;&#34;
        nonlocal best_model
        model = model_arima(data, order, S = S)
        if model.aic &lt; best_model[0]:
            best_model  = [model.aic, model.order, model.S, model]
        return

        
    def findBestModel():
            &#34;&#34;&#34;
            Clockwise cycle
            &#34;&#34;&#34;
            nonlocal best_model
            new_order=best_model[1].copy()
            if new_order[0] &gt; 0:
                new_order[0] = new_order[0] - 1
                minAic(new_order)
                if new_order == best_model[1]:
                    findBestModel()

            new_order = best_model[1].copy()

            if new_order[2] &gt; 0:
                new_order[2] = new_order[2] - 1
                minAic(new_order)
                if new_order == best_model[1]:
                    findBestModel()

            new_order = best_model[1].copy()

            if new_order[0] + 1 &lt;= max_p:
                new_order[0] = new_order[0] + 1
                minAic(new_order)
                if new_order == best_model[1]:
                    findBestModel()

            new_order = best_model[1].copy()

            if new_order[2] + 1 &lt;= max_q:
                new_order[2] = new_order[2] + 1        
                minAic(new_order)
                if new_order == best_model[1]:
                    findBestModel()

            new_order = best_model[1].copy()
            
            if new_order[2] + 1 &lt;= max_q and new_order[0] + 1 &lt;= max_p:
                new_order[2] = new_order[2] + 1   
                new_order[0] = new_order[0] + 1      
                minAic(new_order)
                if new_order == best_model[1]:
                    findBestModel()

            new_order = best_model[1].copy()

            if new_order[2] - 1 &gt; -1 and new_order[0] - 1 &gt; -1:
                new_order[2] = new_order[2] - 1   
                new_order[0] = new_order[0] - 1      
                minAic(new_order)
                if new_order == best_model[1]:
                    findBestModel()

            new_order = best_model[1].copy()
            
            if new_order[2] - 1 &gt; -1 and new_order[0] + 1 &lt;= max_p:
                new_order[2] = new_order[2] - 1   
                new_order[0] = new_order[0] + 1      
                minAic(new_order)
                if new_order == best_model[1]:
                    findBestModel()

            new_order = best_model[1].copy()
            
            if new_order[0] - 1 &gt; -1 and new_order[2] + 1 &lt;= max_q:
                new_order[2] = new_order[2] + 1   
                new_order[0] = new_order[0] - 1      
                minAic(new_order)
                if new_order == best_model[1]:
                    findBestModel()

            new_order = best_model[1].copy()



            return
    
    def findBestModelS():
                &#34;&#34;&#34;
                Clockwise cycle for seasonal model
                &#34;&#34;&#34;
                nonlocal best_model
                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                # Change p, q, P, Q by +-1. If better model found, start over
                if new_order[0] &gt; 0:
                    new_order[0] = new_order[0] - 1
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()    

                if new_order[2] &gt; 0:
                    new_order[2] = new_order[2] - 1
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_S[0] &gt; 0:
                    new_S[0] = new_S[0] - 1 
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_S[2] &gt; 0:
                    new_S[2] = new_S[2] - 1
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()


                if new_order[0] + 1 &lt;= max_p:
                    new_order[0] = new_order[0] + 1
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_order[2] + 1 &lt;= max_q:
                    new_order[2] = new_order[2] + 1
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_S[0] + 1 &lt;= max_P:
                    new_S[0] = new_S[0] + 1
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_S[2] + 1 &lt;= max_Q:
                    new_S[2] = new_S[2] + 1
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()
                
                if new_order[2] + 1 &lt;= max_q and new_order[0] + 1 &lt;= max_p:
                    new_order[2] = new_order[2] + 1   
                    new_order[0] = new_order[0] + 1      
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_order[2] - 1 &gt; -1 and new_order[0] - 1 &gt; -1:
                    new_order[2] = new_order[2] - 1   
                    new_order[0] = new_order[0] - 1      
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_S[2] + 1 &lt;= max_Q and new_S[0] + 1 &lt;= max_P:
                    new_S[2] = new_S[2] + 1   
                    new_S[0] = new_S[0] + 1   
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_S[2] - 1 &gt; -1 and new_S[0] - 1 &gt; -1:
                    new_S[2] = new_S[2] - 1   
                    new_S[0] = new_S[0] - 1  
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_S[2] - 1 &gt; -1 and new_S[0] + 1 &lt;= max_P:
                    new_S[2] = new_S[2] - 1   
                    new_S[0] = new_S[0] + 1  
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_S[0] - 1 &gt; -1 and new_S[2] + 1 &lt;= max_Q:
                    new_S[2] = new_S[2] + 1   
                    new_S[0] = new_S[0] - 1  
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                return 
    

    start = time.process_time()  # Start Timer
    if season is None:
        # initial parameters for clockwise search
        minAic([2, d, 2])
        minAic([0, d, 0])
        minAic([1, d, 0])
        minAic([0, d, 1])
        findBestModel()  # clockwise recursive cycle
        end = time.process_time() - start  # End Timer
        print(&#34;Best model: %s, AIC: %.3f&#34; % (best_model[1], best_model[0]))
        print(&#34;Total time: &#34;, end)
        return best_model[3]
    else:
        # initial parameters for clockwise search for seasonal data
        p = min(2, max_p)
        q = min(2, max_q)
        P = min(1, max_P)
        Q = min(1, max_Q)

        minAicS([p, d, q], [P, D, Q, season])
        minAicS([0, d, 0], [0, D, 0, season])   
        minAicS([1, d, 0], [1, D, 0, season])
        minAicS([0, d, 1], [0, D, 1, season])

        # storing configs to avoid evaluating same set of parameters
        used_configs = [ [[p, d, q], [P, D, Q, season]], [[0, d, 0], [0, D, 0, season]], [[1, D, 0, season], [1, d, 0]], [[0, D, 1, season], [0, d, 1]]]
        findBestModelS()   # clockwise recursive cycle
        end = time.process_time() - start   # End Timer

        print(&#34;Best model: %s %s, AIC: %.3f&#34; % (best_model[1], best_model[2], best_model[0]))
        print(&#34;Total time: &#34;, end)

        return best_model[3]
    

def model_arima(train_data, order, S = None):
    &#34;&#34;&#34;
    Evaluate an ARIMA model for a given order (p,d,q)(P,D,Q,S) and return a model
    Args:
        train_data (DataFrame, ndarray): train dataset to use.
        order (tuple(int, int, int)): p, d, q values.
        S (tuple(int, int, int, int)): P, D, Q, S values. S - season value
    Returns:
        object: ARIMA model.
    &#34;&#34;&#34;
    import warnings
    from statsmodels.tools.sm_exceptions import ConvergenceWarning
    warnings.simplefilter(&#39;ignore&#39;, ConvergenceWarning)
    warnings.simplefilter(&#39;ignore&#39;, UserWarning)
    start = time.process_time()
    if S:
        # create and fit model, assign order and seasonal order to model
        model = ARIMA(train_data, order=order, seasonal_order = S)
        model = model.fit() 
        model.order = order
        model.S = S
        # if root_test fails, set AIC to inf
        model.aic = root_test(model, model.aic)
        end = time.process_time() - start  # End Timer

        if order[1] == 0:
            print(&#39;SARMA%s %s AIC:%.3f  Time_Taken:%.3f&#39; % (order, S, model.aic, end))
        else:
            print(&#39;SARIMA%s %s AIC:%.3f  Time_Taken:%.3f&#39; % (order, S, model.aic, end))  
        return model
    else:
        # create and fit model, assign order and seasonal order to model
        model = ARIMA(train_data, order=order)
        model = model.fit() 
        model.order = order
        model.S = [0,0,0,0]
        # if root_test fails, set AIC to inf
        model.aic = root_test(model, model.aic)
        end = time.process_time() - start  # End Timer

        if order[1] == 0:
            print(&#39;ARMA%s AIC:%.3f  Time_Taken:%.3f&#39; % (order, model.aic, end))
        else:
            print(&#39;ARIMA%s AIC:%.3f  Time_Taken:%.3f&#39; % (order, model.aic, end))
        return model

def make_arima(dataset, order, seasonal_order = None, train_size = 0.9, test_size = None, fig_size = (15,5), plot = True, verbose = True, max_plot = 200):
    &#34;&#34;&#34;
    Create, fit and evaluate a (S)AR(I)MA model.
    
    Args:
        dataset (DataFrame, ndarray): dataset to use.
        order (tuple(int, int, int)): p, d, q values.
        seasonal_order (tuple(int, int, int, int)): P, D, Q, S values. S - season value
        train_size (float): Value from 0 to 1 to specify fraction of train dataset. Default value : 0.9.
        test_size (float): Value from 0 to 1 to specify fraction of test dataset. Not needed if train_size is specified. Default value : 1 - train_size
        fig_size (tuple(int, int)):  size of a plot.
        plot (bool): plot predicted and observed values for test dataset.
        verbose (bool): print additional information.
        max_plot(int): maximum number of values to plot.

    Returns:
        object: ARIMA model.
    &#34;&#34;&#34;
    if not(isinstance(dataset, np.ndarray)):
        dataset = dataset.values
        dataset = dataset.astype(&#39;float64&#39;)

    if (np.isnan(dataset).any()):
        dataset = utils.interpolate_nan(dataset)

    if train_size is None: 
        if test_size is None:
            train_size = 0.9
        else:
            train_size = 1 - test_size

    # split into train and test sets
    train_num = int(len(dataset) * train_size)
    train_x, test_data = dataset[0:train_num], dataset[train_num:]
    model = ARIMA(train_x, order = order, seasonal_order = seasonal_order)
    model = model.fit()
    print(&#34;AIC: &#34;, model.aic)

    predictions = model.forecast(len(test_data))
    test_data = test_data.flatten()
    if plot:
            plt.figure(figsize=fig_size)
            plt.plot(test_data[-max_plot:], label = &#34;Actual&#34;)
            plt.plot(predictions[-max_plot:], label = &#34;Prediction&#34;)               
            plt.ylabel(&#39;Values&#39;, fontsize=15)
            plt.legend()
            plt.show()

    if verbose == False:
        return model
    print(pd.DataFrame({&#39;prediction&#39; : predictions, &#39;actual&#39; : test_data.flatten()}))

    rmse = utils.get_rmse(predictions, test_data)
    mse = utils.get_mse(predictions, test_data)
    mae = utils.get_mae(predictions, test_data)
    mape = utils.get_mape(predictions, test_data)

    print(&#34;RMSE = {}, MSE = {}, MAE = {}, MAPE = {}&#34;.format(rmse, mse, mae, mape))
    return model
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="TSEnsemble.arima.auto_arima"><code class="name flex">
<span>def <span class="ident">auto_arima</span></span>(<span>dataset, method='stepwise', max_p=3, d=None, D=None, max_q=3, season=None, max_P=3, max_Q=3, verbose=True, train_size=None, train_split=None, plot=True, fig_size=(15, 5), max_plot=200)</span>
</code></dt>
<dd>
<div class="desc"><p>Automatically find the best parameters for (S)AR(I)MA model </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dataset</code></strong> :&ensp;<code>DataFrame, ndarray</code></dt>
<dd>dataset to use.</dd>
<dt>method ('stepwise', 'grid'): Method for finding the optimal parameters.</dt>
<dt>d, D (int): specify d, D parameters.</dt>
<dt>max_q, max_p, max_P, max_Q (int): maximum values of parameters.</dt>
<dt><strong><code>season</code></strong> :&ensp;<code>int</code></dt>
<dd>required for Seasonal ARIMA. Seasonality of time series.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>print additional information.</dd>
<dt><strong><code>train_size</code></strong> :&ensp;<code>float</code></dt>
<dd>Value from 0 to 1 to specify fraction of train dataset. Default value : 0.9. alias : train_split</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>bool</code></dt>
<dd>plot predicted and observed values for test dataset.</dd>
</dl>
<p>fig_size (tuple(int, int)):
size of a plot.
max_plot(int): maximum number of values to plot.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>Optimal ARIMA model.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def auto_arima(dataset, 
               method = &#39;stepwise&#39;, 
               max_p = 3, 
               d = None, 
               D = None, 
               max_q = 3, 
               season = None, 
               max_P = 3, 
               max_Q = 3, 
               verbose = True, 
               train_size = None,
               train_split = None, 
               plot = True, 
               fig_size = (15,5),
               max_plot = 200):
    &#34;&#34;&#34;
    Automatically find the best parameters for (S)AR(I)MA model 
    
    Args:
        dataset (DataFrame, ndarray): dataset to use.
        method (&#39;stepwise&#39;, &#39;grid&#39;): Method for finding the optimal parameters.
        d, D (int): specify d, D parameters.
        max_q, max_p, max_P, max_Q (int): maximum values of parameters.
        season (int): required for Seasonal ARIMA. Seasonality of time series.
        verbose (bool): print additional information.
        train_size (float): Value from 0 to 1 to specify fraction of train dataset. Default value : 0.9. alias : train_split
        plot (bool): plot predicted and observed values for test dataset.
        fig_size (tuple(int, int)):  size of a plot.
        max_plot(int): maximum number of values to plot.

    Returns:
        object: Optimal ARIMA model.
    &#34;&#34;&#34;

    if train_size is None and train_split is None:
        train_split = 0.9
    elif train_split is None and not(train_size is None):
        train_split = train_size

    if hasattr(dataset, &#39;values&#39;):
        dataset = dataset.values
    
    if (np.isnan(dataset).any()):
        dataset = utils.interpolate_nan(dataset)

    # try to find correct d value
    is_stationary = utils.isStationaryArray(dataset, plot = False, verbose = False)
    if not(is_stationary) and d is None:
        for i in range(3):
                # check if differentiating i times makes data stationary
                if utils.isStationaryArray(np.diff(dataset.squeeze(), n = i + 1), plot = False, verbose = False):
                    d = i + 1
                    break
        if d is None:
            print(&#34;Cannot transform data to Stationary. Using ARIMA model would be inappropriate&#34;)
            d = 3
    elif d is None:
        d = 0
    if D is None:
       D = d     


    train_size = int(len(dataset) * train_split)
    train_data = dataset[:train_size]
    test_data = dataset[train_size:]
    train_data = list(np.concatenate(train_data).flat) 
    test_data = list(np.concatenate(test_data).flat) 


    if method == &#39;stepwise&#39;:
        model = stepwise_auto_arima(train_data, max_p = max_p, d = d, max_q = max_q, season = season, max_P = max_P, D = D, max_Q = max_Q)
    elif method == &#39;grid&#39;:
        model = grid_auto_arima(train_data, max_p = max_p, d = d, max_q = max_q, season = season, max_P = max_P, D = D, max_Q = max_Q)
    else:
        return &#34;method should be grid or stepwise&#34;

    predictions = model.forecast(len(test_data))

    if plot:
            plt.figure(figsize=fig_size)
            plt.plot(test_data[-max_plot:], label = &#34;Actual&#34;)
            plt.plot(predictions[-max_plot:], label = &#34;Prediction&#34;)               
            plt.ylabel(&#39;Values&#39;, fontsize=15)
            plt.legend()
            plt.show()

    if verbose == False:
        return model
    
    print(pd.DataFrame({&#39;prediction&#39; : predictions, &#39;actual&#39; : test_data}))

    rmse = utils.get_rmse(predictions, test_data)
    mse = utils.get_mse(predictions, test_data)
    mae = utils.get_mae(predictions, test_data)
    mape = utils.get_mape(predictions, test_data)

    print(&#34;RMSE = {}, MSE = {}, MAE = {}, MAPE = {}&#34;.format(rmse, mse, mae, mape))

    return model</code></pre>
</details>
</dd>
<dt id="TSEnsemble.arima.grid_auto_arima"><code class="name flex">
<span>def <span class="ident">grid_auto_arima</span></span>(<span>data, max_p=3, d=None, max_q=3, season=None, max_P=3, D=None, max_Q=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate combinations of p, d and q values for an ARIMA model using grid search</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>DataFrame, ndarray</code></dt>
<dd>dataset to use.</dd>
<dt>d, D (int): specify d, D parameters.</dt>
<dt>max_q, max_p, max_P, max_Q (int): maximum values of parameters.</dt>
<dt><strong><code>season</code></strong> :&ensp;<code>int</code></dt>
<dd>required for Seasonal ARIMA. Seasonality of time series.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>Optimal ARIMA model.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grid_auto_arima(data, max_p = 3, d = None, max_q = 3, season = None, max_P = 3, D = None, max_Q = 3):
    &#34;&#34;&#34;
    Evaluate combinations of p, d and q values for an ARIMA model using grid search
    Args:
        data (DataFrame, ndarray): dataset to use.
        d, D (int): specify d, D parameters.
        max_q, max_p, max_P, max_Q (int): maximum values of parameters.
        season (int): required for Seasonal ARIMA. Seasonality of time series.
    Returns:
        object: Optimal ARIMA model.
    &#34;&#34;&#34;
    
    best_aic, best_model, = float(&#34;inf&#34;), None
    if season is None:
        for p in range(0, max_p + 1):
            for q in range(0, max_q + 1):
                try:
                    if p == 0 and q == 0:
                        continue
                    model = model_arima(data, [p, d, q])
                    if model.aic &lt; best_aic:
                        best_aic, best_model = model.aic, model
                except:
                    continue
        if d == 0:
            print(&#39;Best ARMA%s  AIC=%.3f&#39; % (best_model, best_aic))
        else:
            print(&#39;Best ARIMA%s  AIC=%.3f&#39; % (best_model, best_aic))
    else:
        for p in range(0, max_p + 1):
            for q in range(0, max_q + 1):
                for P in range(0, max_P + 1):
                    for Q in range(0, max_Q + 1):
                        try:
                            if p == 0 and q == 0:
                                continue
                            model = model_arima(data, (p, d, q), S = (P, D, Q, season))
                            if model.aic &lt; best_aic:
                                best_aic, best_model = model.aic, model
                        except:
                                continue
        if d == 0 and D == 0:
            print(&#39;Best SARMA%s  AIC=%.3f&#39; % (best_model.order, best_aic))
        else:
            print(&#39;Best SARIMA%s  AIC=%.3f&#39; % (best_model.order, best_aic))
    return best_model</code></pre>
</details>
</dd>
<dt id="TSEnsemble.arima.make_arima"><code class="name flex">
<span>def <span class="ident">make_arima</span></span>(<span>dataset, order, seasonal_order=None, train_size=0.9, test_size=None, fig_size=(15, 5), plot=True, verbose=True, max_plot=200)</span>
</code></dt>
<dd>
<div class="desc"><p>Create, fit and evaluate a (S)AR(I)MA model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dataset</code></strong> :&ensp;<code>DataFrame, ndarray</code></dt>
<dd>dataset to use.</dd>
<dt>order (tuple(int, int, int)): p, d, q values.</dt>
<dt>seasonal_order (tuple(int, int, int, int)): P, D, Q, S values. S - season value</dt>
<dt><strong><code>train_size</code></strong> :&ensp;<code>float</code></dt>
<dd>Value from 0 to 1 to specify fraction of train dataset. Default value : 0.9.</dd>
<dt><strong><code>test_size</code></strong> :&ensp;<code>float</code></dt>
<dd>Value from 0 to 1 to specify fraction of test dataset. Not needed if train_size is specified. Default value : 1 - train_size</dd>
<dt>fig_size (tuple(int, int)):
size of a plot.</dt>
<dt><strong><code>plot</code></strong> :&ensp;<code>bool</code></dt>
<dd>plot predicted and observed values for test dataset.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>print additional information.</dd>
</dl>
<p>max_plot(int): maximum number of values to plot.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>ARIMA model.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_arima(dataset, order, seasonal_order = None, train_size = 0.9, test_size = None, fig_size = (15,5), plot = True, verbose = True, max_plot = 200):
    &#34;&#34;&#34;
    Create, fit and evaluate a (S)AR(I)MA model.
    
    Args:
        dataset (DataFrame, ndarray): dataset to use.
        order (tuple(int, int, int)): p, d, q values.
        seasonal_order (tuple(int, int, int, int)): P, D, Q, S values. S - season value
        train_size (float): Value from 0 to 1 to specify fraction of train dataset. Default value : 0.9.
        test_size (float): Value from 0 to 1 to specify fraction of test dataset. Not needed if train_size is specified. Default value : 1 - train_size
        fig_size (tuple(int, int)):  size of a plot.
        plot (bool): plot predicted and observed values for test dataset.
        verbose (bool): print additional information.
        max_plot(int): maximum number of values to plot.

    Returns:
        object: ARIMA model.
    &#34;&#34;&#34;
    if not(isinstance(dataset, np.ndarray)):
        dataset = dataset.values
        dataset = dataset.astype(&#39;float64&#39;)

    if (np.isnan(dataset).any()):
        dataset = utils.interpolate_nan(dataset)

    if train_size is None: 
        if test_size is None:
            train_size = 0.9
        else:
            train_size = 1 - test_size

    # split into train and test sets
    train_num = int(len(dataset) * train_size)
    train_x, test_data = dataset[0:train_num], dataset[train_num:]
    model = ARIMA(train_x, order = order, seasonal_order = seasonal_order)
    model = model.fit()
    print(&#34;AIC: &#34;, model.aic)

    predictions = model.forecast(len(test_data))
    test_data = test_data.flatten()
    if plot:
            plt.figure(figsize=fig_size)
            plt.plot(test_data[-max_plot:], label = &#34;Actual&#34;)
            plt.plot(predictions[-max_plot:], label = &#34;Prediction&#34;)               
            plt.ylabel(&#39;Values&#39;, fontsize=15)
            plt.legend()
            plt.show()

    if verbose == False:
        return model
    print(pd.DataFrame({&#39;prediction&#39; : predictions, &#39;actual&#39; : test_data.flatten()}))

    rmse = utils.get_rmse(predictions, test_data)
    mse = utils.get_mse(predictions, test_data)
    mae = utils.get_mae(predictions, test_data)
    mape = utils.get_mape(predictions, test_data)

    print(&#34;RMSE = {}, MSE = {}, MAE = {}, MAPE = {}&#34;.format(rmse, mse, mae, mape))
    return model</code></pre>
</details>
</dd>
<dt id="TSEnsemble.arima.model_arima"><code class="name flex">
<span>def <span class="ident">model_arima</span></span>(<span>train_data, order, S=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate an ARIMA model for a given order (p,d,q)(P,D,Q,S) and return a model</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>train_data</code></strong> :&ensp;<code>DataFrame, ndarray</code></dt>
<dd>train dataset to use.</dd>
</dl>
<p>order (tuple(int, int, int)): p, d, q values.
S (tuple(int, int, int, int)): P, D, Q, S values. S - season value</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>ARIMA model.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_arima(train_data, order, S = None):
    &#34;&#34;&#34;
    Evaluate an ARIMA model for a given order (p,d,q)(P,D,Q,S) and return a model
    Args:
        train_data (DataFrame, ndarray): train dataset to use.
        order (tuple(int, int, int)): p, d, q values.
        S (tuple(int, int, int, int)): P, D, Q, S values. S - season value
    Returns:
        object: ARIMA model.
    &#34;&#34;&#34;
    import warnings
    from statsmodels.tools.sm_exceptions import ConvergenceWarning
    warnings.simplefilter(&#39;ignore&#39;, ConvergenceWarning)
    warnings.simplefilter(&#39;ignore&#39;, UserWarning)
    start = time.process_time()
    if S:
        # create and fit model, assign order and seasonal order to model
        model = ARIMA(train_data, order=order, seasonal_order = S)
        model = model.fit() 
        model.order = order
        model.S = S
        # if root_test fails, set AIC to inf
        model.aic = root_test(model, model.aic)
        end = time.process_time() - start  # End Timer

        if order[1] == 0:
            print(&#39;SARMA%s %s AIC:%.3f  Time_Taken:%.3f&#39; % (order, S, model.aic, end))
        else:
            print(&#39;SARIMA%s %s AIC:%.3f  Time_Taken:%.3f&#39; % (order, S, model.aic, end))  
        return model
    else:
        # create and fit model, assign order and seasonal order to model
        model = ARIMA(train_data, order=order)
        model = model.fit() 
        model.order = order
        model.S = [0,0,0,0]
        # if root_test fails, set AIC to inf
        model.aic = root_test(model, model.aic)
        end = time.process_time() - start  # End Timer

        if order[1] == 0:
            print(&#39;ARMA%s AIC:%.3f  Time_Taken:%.3f&#39; % (order, model.aic, end))
        else:
            print(&#39;ARIMA%s AIC:%.3f  Time_Taken:%.3f&#39; % (order, model.aic, end))
        return model</code></pre>
</details>
</dd>
<dt id="TSEnsemble.arima.root_test"><code class="name flex">
<span>def <span class="ident">root_test</span></span>(<span>model, aic)</span>
</code></dt>
<dd>
<div class="desc"><p>Check the roots of the new model, and set AIC to inf if the roots are
near non-invertible. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>object</code></dt>
<dd>Model object.</dd>
<dt><strong><code>aic</code></strong> :&ensp;<code>float</code></dt>
<dd>AIC value of model.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Updated AIC value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def root_test(model, aic):
    &#34;&#34;&#34;
    Check the roots of the new model, and set AIC to inf if the roots are
    near non-invertible. 
    Args:
        model (object): Model object.
        aic (float): AIC value of model.

    Returns:
        float: Updated AIC value.
    &#34;&#34;&#34;
    max_invroot = 0
    p, d, q = model.order
    P, D, Q, m = model.S

    if p + P &gt; 0:
        max_invroot = max(0, *np.abs(1 / model.arroots))
    if q + Q &gt; 0 and np.isfinite(aic):
        max_invroot = max(0, *np.abs(1 / model.maroots))

    if max_invroot &gt; 0.99:
        aic = np.inf
    return aic</code></pre>
</details>
</dd>
<dt id="TSEnsemble.arima.stepwise_auto_arima"><code class="name flex">
<span>def <span class="ident">stepwise_auto_arima</span></span>(<span>data, max_p=3, d=None, max_q=3, season=None, max_P=3, D=None, max_Q=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Stepwise approach to find the best parameters for (S)AR(I)MA model</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>DataFrame, ndarray</code></dt>
<dd>dataset to use.</dd>
<dt>d, D (int): specify d, D parameters.</dt>
<dt>max_q, max_p, max_P, max_Q (int): maximum values of parameters.</dt>
<dt><strong><code>season</code></strong> :&ensp;<code>int</code></dt>
<dd>required for Seasonal ARIMA. Seasonality of time series.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>Optimal ARIMA model.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stepwise_auto_arima(data, max_p = 3, d = None, max_q = 3, season = None, max_P = 3, D = None, max_Q = 3):
    &#34;&#34;&#34;
    Stepwise approach to find the best parameters for (S)AR(I)MA model
    Args:
        data (DataFrame, ndarray): dataset to use.
        d, D (int): specify d, D parameters.
        max_q, max_p, max_P, max_Q (int): maximum values of parameters.
        season (int): required for Seasonal ARIMA. Seasonality of time series.
    Returns:
        object: Optimal ARIMA model.
    &#34;&#34;&#34;

    best_model = [np.inf,[],[],None]

    def minAic(order):
        &#34;&#34;&#34;
        Compare given parameters of model to the current best
        &#34;&#34;&#34;
        nonlocal best_model
        model = model_arima(data, order)
        if model.aic &lt; best_model[0]:
            best_model[0], best_model[1], best_model[3] = model.aic, order, model
        return 
    
    def minAicS(order, S):
        &#34;&#34;&#34;
        Compare given parameters of model to the current best for Seasonal AR(I)MA
        &#34;&#34;&#34;
        nonlocal best_model
        model = model_arima(data, order, S = S)
        if model.aic &lt; best_model[0]:
            best_model  = [model.aic, model.order, model.S, model]
        return

        
    def findBestModel():
            &#34;&#34;&#34;
            Clockwise cycle
            &#34;&#34;&#34;
            nonlocal best_model
            new_order=best_model[1].copy()
            if new_order[0] &gt; 0:
                new_order[0] = new_order[0] - 1
                minAic(new_order)
                if new_order == best_model[1]:
                    findBestModel()

            new_order = best_model[1].copy()

            if new_order[2] &gt; 0:
                new_order[2] = new_order[2] - 1
                minAic(new_order)
                if new_order == best_model[1]:
                    findBestModel()

            new_order = best_model[1].copy()

            if new_order[0] + 1 &lt;= max_p:
                new_order[0] = new_order[0] + 1
                minAic(new_order)
                if new_order == best_model[1]:
                    findBestModel()

            new_order = best_model[1].copy()

            if new_order[2] + 1 &lt;= max_q:
                new_order[2] = new_order[2] + 1        
                minAic(new_order)
                if new_order == best_model[1]:
                    findBestModel()

            new_order = best_model[1].copy()
            
            if new_order[2] + 1 &lt;= max_q and new_order[0] + 1 &lt;= max_p:
                new_order[2] = new_order[2] + 1   
                new_order[0] = new_order[0] + 1      
                minAic(new_order)
                if new_order == best_model[1]:
                    findBestModel()

            new_order = best_model[1].copy()

            if new_order[2] - 1 &gt; -1 and new_order[0] - 1 &gt; -1:
                new_order[2] = new_order[2] - 1   
                new_order[0] = new_order[0] - 1      
                minAic(new_order)
                if new_order == best_model[1]:
                    findBestModel()

            new_order = best_model[1].copy()
            
            if new_order[2] - 1 &gt; -1 and new_order[0] + 1 &lt;= max_p:
                new_order[2] = new_order[2] - 1   
                new_order[0] = new_order[0] + 1      
                minAic(new_order)
                if new_order == best_model[1]:
                    findBestModel()

            new_order = best_model[1].copy()
            
            if new_order[0] - 1 &gt; -1 and new_order[2] + 1 &lt;= max_q:
                new_order[2] = new_order[2] + 1   
                new_order[0] = new_order[0] - 1      
                minAic(new_order)
                if new_order == best_model[1]:
                    findBestModel()

            new_order = best_model[1].copy()



            return
    
    def findBestModelS():
                &#34;&#34;&#34;
                Clockwise cycle for seasonal model
                &#34;&#34;&#34;
                nonlocal best_model
                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                # Change p, q, P, Q by +-1. If better model found, start over
                if new_order[0] &gt; 0:
                    new_order[0] = new_order[0] - 1
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()    

                if new_order[2] &gt; 0:
                    new_order[2] = new_order[2] - 1
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_S[0] &gt; 0:
                    new_S[0] = new_S[0] - 1 
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_S[2] &gt; 0:
                    new_S[2] = new_S[2] - 1
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()


                if new_order[0] + 1 &lt;= max_p:
                    new_order[0] = new_order[0] + 1
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_order[2] + 1 &lt;= max_q:
                    new_order[2] = new_order[2] + 1
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_S[0] + 1 &lt;= max_P:
                    new_S[0] = new_S[0] + 1
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_S[2] + 1 &lt;= max_Q:
                    new_S[2] = new_S[2] + 1
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()
                
                if new_order[2] + 1 &lt;= max_q and new_order[0] + 1 &lt;= max_p:
                    new_order[2] = new_order[2] + 1   
                    new_order[0] = new_order[0] + 1      
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_order[2] - 1 &gt; -1 and new_order[0] - 1 &gt; -1:
                    new_order[2] = new_order[2] - 1   
                    new_order[0] = new_order[0] - 1      
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_S[2] + 1 &lt;= max_Q and new_S[0] + 1 &lt;= max_P:
                    new_S[2] = new_S[2] + 1   
                    new_S[0] = new_S[0] + 1   
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_S[2] - 1 &gt; -1 and new_S[0] - 1 &gt; -1:
                    new_S[2] = new_S[2] - 1   
                    new_S[0] = new_S[0] - 1  
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_S[2] - 1 &gt; -1 and new_S[0] + 1 &lt;= max_P:
                    new_S[2] = new_S[2] - 1   
                    new_S[0] = new_S[0] + 1  
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                if new_S[0] - 1 &gt; -1 and new_S[2] + 1 &lt;= max_Q:
                    new_S[2] = new_S[2] + 1   
                    new_S[0] = new_S[0] - 1  
                    if not([new_order, new_S] in used_configs):
                        minAicS(new_order, new_S)
                        used_configs.append([new_order, new_S])
                        if  best_model[1] == new_order and best_model[2] == new_S:
                            findBestModelS()

                new_order = best_model[1].copy()
                new_S = best_model[2].copy()

                return 
    

    start = time.process_time()  # Start Timer
    if season is None:
        # initial parameters for clockwise search
        minAic([2, d, 2])
        minAic([0, d, 0])
        minAic([1, d, 0])
        minAic([0, d, 1])
        findBestModel()  # clockwise recursive cycle
        end = time.process_time() - start  # End Timer
        print(&#34;Best model: %s, AIC: %.3f&#34; % (best_model[1], best_model[0]))
        print(&#34;Total time: &#34;, end)
        return best_model[3]
    else:
        # initial parameters for clockwise search for seasonal data
        p = min(2, max_p)
        q = min(2, max_q)
        P = min(1, max_P)
        Q = min(1, max_Q)

        minAicS([p, d, q], [P, D, Q, season])
        minAicS([0, d, 0], [0, D, 0, season])   
        minAicS([1, d, 0], [1, D, 0, season])
        minAicS([0, d, 1], [0, D, 1, season])

        # storing configs to avoid evaluating same set of parameters
        used_configs = [ [[p, d, q], [P, D, Q, season]], [[0, d, 0], [0, D, 0, season]], [[1, D, 0, season], [1, d, 0]], [[0, D, 1, season], [0, d, 1]]]
        findBestModelS()   # clockwise recursive cycle
        end = time.process_time() - start   # End Timer

        print(&#34;Best model: %s %s, AIC: %.3f&#34; % (best_model[1], best_model[2], best_model[0]))
        print(&#34;Total time: &#34;, end)

        return best_model[3]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="TSEnsemble" href="index.html">TSEnsemble</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="TSEnsemble.arima.auto_arima" href="#TSEnsemble.arima.auto_arima">auto_arima</a></code></li>
<li><code><a title="TSEnsemble.arima.grid_auto_arima" href="#TSEnsemble.arima.grid_auto_arima">grid_auto_arima</a></code></li>
<li><code><a title="TSEnsemble.arima.make_arima" href="#TSEnsemble.arima.make_arima">make_arima</a></code></li>
<li><code><a title="TSEnsemble.arima.model_arima" href="#TSEnsemble.arima.model_arima">model_arima</a></code></li>
<li><code><a title="TSEnsemble.arima.root_test" href="#TSEnsemble.arima.root_test">root_test</a></code></li>
<li><code><a title="TSEnsemble.arima.stepwise_auto_arima" href="#TSEnsemble.arima.stepwise_auto_arima">stepwise_auto_arima</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>